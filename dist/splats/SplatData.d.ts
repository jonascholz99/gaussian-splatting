import { Vector3 } from "../math/Vector3";
import { Quaternion } from "../math/Quaternion";
declare class SplatData {
    static RowLength: number;
    private firstTime;
    changed: boolean;
    detached: boolean;
    private _vertexCount;
    private _renderedSplats;
    private _positions;
    private _rotations;
    private _scales;
    private _colors;
    private _selection;
    private _rendered;
    private _renderedPositions;
    private _renderedRotations;
    private _renderedScales;
    private _renderedColors;
    private _renderedSelection;
    translate: (translation: Vector3) => void;
    rotate: (rotation: Quaternion) => void;
    scale: (scale: Vector3) => void;
    serialize: () => Uint8Array;
    reattach: (positions: ArrayBufferLike, rotations: ArrayBufferLike, scales: ArrayBufferLike, colors: ArrayBufferLike, selection: ArrayBufferLike, rendered: ArrayBufferLike) => void;
    resetRendering: () => void;
    constructor(vertexCount?: number, positions?: Float32Array | null, rotations?: Float32Array | null, scales?: Float32Array | null, colors?: Uint8Array | null);
    static Deserialize(data: Uint8Array): SplatData;
    get vertexCount(): number;
    get renderedSplats(): number;
    get positions(): Float32Array;
    get renderedPositions(): Float32Array;
    get rotations(): Float32Array;
    get renderedRotations(): Float32Array;
    get scales(): Float32Array;
    get renderedScales(): Float32Array;
    get colors(): Uint8Array;
    get renderedColors(): Uint8Array;
    get selection(): Uint8Array;
    get renderedSelection(): Uint8Array;
    get rendered(): Uint8Array;
    calculateRenderedTransforms(): void;
}
export { SplatData };
